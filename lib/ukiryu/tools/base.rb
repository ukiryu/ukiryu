# frozen_string_literal: true

require_relative '../runtime'
require_relative '../command_builder'
require_relative 'class_generator'
require_relative 'executable_finder'

module Ukiryu
  # Tools namespace for tool-specific classes
  #
  # This namespace contains dynamically generated classes for each tool,
  # providing a fully OOP interface for working with command-line tools.
  #
  # @example
  #   Ukiryu::Tools::Imagemagick.new.tap do |tool|
  #     options = tool.options_for(:convert)
  #     options.set(inputs: ["image.png"], resize: "50%")
  #     options.run
  #   end
  module Tools
    # Abstract base class for all tool-specific classes
    #
    # This class provides the common interface that all tool classes inherit from.
    # Tool-specific classes are dynamically generated by Tools::Generator.
    #
    # @abstract
    class Base
      include Ukiryu::CommandBuilder
      class << self
        # Get the tool name symbol
        #
        # @return [Symbol] the tool name
        attr_reader :tool_name

        # Get the tool definition model
        #
        # @return [Models::ToolDefinition] the tool definition
        attr_reader :tool_definition

        # Get the platform profile model
        #
        # @return [Models::PlatformProfile] the platform profile
        attr_reader :platform_profile

        # Get the options class for a specific command
        #
        # @param command_name [Symbol] the command name
        # @return [Class] the options class for this command
        def options_class_for(command_name)
          command_name = command_name.to_sym
          @options_classes ||= {}
          return @options_classes[command_name] if @options_classes[command_name]

          # Get command from platform profile model
          command_def = @platform_profile.command(command_name.to_s)
          raise ArgumentError, "Unknown command: #{command_name}" unless command_def

          # Generate the options class using ClassGenerator
          options_class = ClassGenerator.generate_options_class(self, command_name, command_def)
          @options_classes[command_name] = options_class
          options_class
        end

        # Alias for options_class_for (more idiomatic)
        #
        # @param command_name [Symbol] the command name
        # @return [Class] the options class for this command
        def options_for(command_name)
          options_class_for(command_name)
        end

        # Get the action class for a specific command
        #
        # @param command_name [Symbol] the command name
        # @return [Class] the action class for this command
        def action_class_for(command_name)
          command_name = command_name.to_sym
          @action_classes ||= {}
          return @action_classes[command_name] if @action_classes[command_name]

          # Get command from platform profile model
          command_def = @platform_profile.command(command_name.to_s)
          raise ArgumentError, "Unknown command: #{command_name}" unless command_def

          # Generate the action class using ClassGenerator
          action_class = ClassGenerator.generate_action_class(self, command_name, command_def)
          @action_classes[command_name] = action_class
          action_class
        end

        # Alias for action_class_for
        #
        # @param command_name [Symbol] the command name
        # @return [Class] the action class for this command
        def action_for(command_name)
          action_class_for(command_name)
        end

        # Get version information for this tool
        #
        # @return [Version, nil] version object if tool is available
        def version
          return nil unless available?

          new.version
        end

        # Check if the tool is available on this system
        #
        # @return [Boolean] true if the tool can be executed
        def available?
          @available ||= begin
            executable = ExecutableFinder.find_executable(@tool_definition.name.to_s, @tool_definition)
            !executable.nil?
          end
        end

        # Get the response class for a command
        #
        # @param command_name [Symbol] the command name
        # @return [Class] the response class
        def response_class_for(command_name)
          command_name = command_name.to_sym
          @response_classes ||= {}
          return @response_classes[command_name] if @response_classes[command_name]

          # Get command from platform profile model
          command_def = @platform_profile.command(command_name.to_s)
          raise ArgumentError, "Unknown command: #{command_name}" unless command_def

          # Generate the response class using ClassGenerator
          response_class = ClassGenerator.generate_response_class(self, command_name, command_def)
          @response_classes[command_name] = response_class
          response_class
        end
      end

      # Initialize the tool instance
      #
      # Sets up shell and platform instance variables for CommandBuilder
      def initialize
        runtime = Ukiryu::Runtime.instance
        @platform = runtime.platform
        @shell = runtime.shell
      end

      # Get the tool name for this instance
      #
      # @return [Symbol] the tool name
      def tool_name
        self.class.tool_name
      end

      # Get the tool name from the tool definition
      #
      # @return [String] the tool name
      def name
        self.class.tool_definition.name
      end

      # Get the tool definition (for backward compatibility)
      #
      # @return [Models::ToolDefinition] the tool definition
      def tool_definition
        self.class.tool_definition
      end

      # Get the platform profile (for backward compatibility)
      #
      # @return [Models::PlatformProfile] the platform profile
      def platform_profile
        self.class.platform_profile
      end

      # Get a new options instance for a command
      #
      # @param command_name [Symbol] the command name
      # @return [Options::Base] a new options instance
      def options_for(command_name)
        self.class.options_for(command_name).new
      end

      # Get the options class for a command
      #
      # @param command_name [Symbol] the command name
      # @return [Class] the options class
      def options_class_for(command_name)
        self.class.options_for(command_name)
      end

      # Get a new action instance for a command
      #
      # @param command_name [Symbol] the command name
      # @return [Action::Base] a new action instance
      def action_for(command_name)
        self.class.action_for(command_name).new(self)
      end

      # Get the action class for a command
      #
      # @param command_name [Symbol] the command name
      # @return [Class] the action class
      def action_class_for(command_name)
        self.class.action_for(command_name)
      end

      # Get version information
      #
      # @return [String, nil] version string if tool is available
      def version
        return @version if defined?(@version)

        @version = detect_version
      end

      # Check if the tool is available
      #
      # @return [Boolean] true if the tool can be executed
      def available?
        self.class.available?
      end

      # Execute a command with options object
      #
      # @param command_name [Symbol] the command to execute
      # @param options [Object] the options object
      # @return [Response::Base] the execution response
      def execute(command_name, options)
        require_relative '../executor'
        require_relative '../options_builder'

        command_name = command_name.to_sym
        # Get command from platform profile model
        command_def = self.class.platform_profile.command(command_name.to_s)

        raise ArgumentError, "Unknown command: #{command_name}" unless command_def

        # Convert options to hash
        params = if options.is_a?(Hash)
                   options.transform_keys(&:to_sym)
                 else
                   Ukiryu::OptionsBuilder.to_hash(options)
                 end

        # Build arguments
        args = build_args(command_def, params)

        # Find executable using ExecutableFinder
        executable = ExecutableFinder.find_executable(self.class.tool_definition.name.to_s, self.class.tool_definition)

        # Get shell
        shell_sym = Ukiryu::Runtime.instance.shell

        # Build environment variables (including env var sets)
        env = build_execution_env(command_def, @platform_profile, params)

        # Execute
        result = Ukiryu::Executor.execute(
          executable,
          args,
          env: env,
          timeout: self.class.tool_definition.timeout || 90,
          shell: shell_sym
        )

        # Build response
        build_response(command_name, result)
      end

      private

      # Build command arguments from parameters
      #
      # This method extends the CommandBuilder implementation to handle
      # extra_args for manual option injection.
      #
      # @param command_def [Models::CommandDefinition] the command definition
      # @param params [Hash] the parameters
      # @return [Array<String>] the command arguments
      def build_args(command_def, params)
        # Call CommandBuilder's build_args first
        args = super

        # Handle extra_args for manual option injection
        # This allows users to pass options not defined in the YAML profile
        if params[:extra_args]
          extra = params[:extra_args]
          shell_sym = Ukiryu::Runtime.instance.shell

          if extra.is_a?(Array)
            shell_class = Ukiryu::Shell.class_for(shell_sym)
            shell_instance = shell_class.new
            extra.each { |arg| args << shell_instance.escape(arg.to_s) }
          else
            args << extra.to_s
          end
        end

        args
      end

      # Build execution environment
      #
      # @param command_def [Models::CommandDefinition] the command definition
      # @param profile [Models::PlatformProfile] the profile (for env_var_sets)
      # @param params [Hash] the parameters
      # @return [Hash] environment variables
      def build_execution_env(command_def, profile, params)
        build_env_vars(command_def, profile, params)
      end

      # Check if command needs batch processing flag for headless mode
      #
      # @param command_def [Models::CommandDefinition] the command definition
      # @return [Boolean] true if batch processing flag should be added
      def needs_batch_process_flag?(command_def)
        # Check if command uses the 'headless' env var set
        command_def.use_env_vars&.include?('headless') || false
      end

      # Build a response object
      #
      # @param command_name [Symbol] the command name
      # @param result [Executor::Result] the execution result
      # @return [Response::Base] the response object
      def build_response(command_name, result)
        require_relative '../response/base'

        # Get the response class for this command
        response_class = self.class.response_class_for(command_name)

        # Create response instance
        response_class.new(result)
      end

      # Detect the tool version
      #
      # @return [String, nil] the detected version string
      def detect_version
        vd = self.class.tool_definition.version_detection
        return nil unless vd

        # Only attempt version detection if command is configured
        return nil if vd.command.nil? || vd.command.empty?

        cmd = vd.command

        executable = ExecutableFinder.find_executable(self.class.tool_definition.name.to_s, self.class.tool_definition)
        return nil unless executable

        require_relative '../executor'
        shell_sym = Ukiryu::Runtime.instance.shell

        result = Ukiryu::Executor.execute(executable, [cmd], shell: shell_sym)
        return nil unless result.success?

        # Convert pattern string to regex if needed
        pattern = if vd.pattern.is_a?(String)
                    Regexp.new(vd.pattern)
                  else
                    vd.pattern || /(\d+\.\d+)/
                  end
        match = result.stdout.match(pattern) || result.stderr.match(pattern)
        match[1] if match
      end
    end
  end
end
