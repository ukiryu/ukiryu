# frozen_string_literal: true

module Ukiryu
  # Tools namespace for tool-specific classes
  #
  # This namespace contains dynamically generated classes for each tool,
  # providing a fully OOP interface for working with command-line tools.
  #
  # @example
  #   Ukiryu::Tools::Imagemagick.new.tap do |tool|
  #     options = tool.options_for(:convert)
  #     options.set(inputs: ["image.png"], resize: "50%")
  #     options.run
  #   end
  module Tools
    # Abstract base class for all tool-specific classes
    #
    # This class provides the common interface that all tool classes inherit from.
    # Tool-specific classes are dynamically generated by Tools::Generator.
    #
    # @abstract
    class Base
      include Ukiryu::CommandBuilder
      class << self
        # Get the tool name symbol
        #
        # @return [Symbol] the tool name
        attr_reader :tool_name

        # Get the tool definition model
        #
        # @return [Models::ToolDefinition] the tool definition
        attr_reader :tool_definition

        # Get the platform profile model
        #
        # @return [Models::PlatformProfile] the platform profile
        attr_reader :platform_profile

        # Get the options class for a specific command
        #
        # @param command_name [Symbol] the command name
        # @return [Class] the options class for this command
        def options_class_for(command_name)
          command_name = command_name.to_sym
          @options_classes ||= {}
          return @options_classes[command_name] if @options_classes[command_name]

          # Get command from platform profile model
          command_def = @platform_profile.command(command_name.to_s)
          raise ArgumentError, "Unknown command: #{command_name}" unless command_def

          # Generate the options class using ClassGenerator
          options_class = Ukiryu::Tools::ClassGenerator.generate_options_class(self, command_name, command_def)
          @options_classes[command_name] = options_class
          options_class
        end

        # Alias for options_class_for (more idiomatic)
        #
        # @param command_name [Symbol] the command name
        # @return [Class] the options class for this command
        def options_for(command_name)
          options_class_for(command_name)
        end

        # Get the action class for a specific command
        #
        # @param command_name [Symbol] the command name
        # @return [Class] the action class for this command
        def action_class_for(command_name)
          command_name = command_name.to_sym
          @action_classes ||= {}
          return @action_classes[command_name] if @action_classes[command_name]

          # Get command from platform profile model
          command_def = @platform_profile.command(command_name.to_s)
          raise ArgumentError, "Unknown command: #{command_name}" unless command_def

          # Generate the action class using ClassGenerator
          action_class = Ukiryu::Tools::ClassGenerator.generate_action_class(self, command_name, command_def)
          @action_classes[command_name] = action_class
          action_class
        end

        # Alias for action_class_for
        #
        # @param command_name [Symbol] the command name
        # @return [Class] the action class for this command
        def action_for(command_name)
          action_class_for(command_name)
        end

        # Get version information for this tool
        #
        # @return [Version, nil] version object if tool is available
        def version
          return nil unless available?

          new.version
        end

        # Check if the tool is available on this system
        #
        # @return [Boolean] true if the tool can be executed
        def available?
          @available ||= begin
            # Check for compatible profile first
            return false unless platform_profile

            executable = Ukiryu::ExecutableFinder.find_executable(@tool_definition.name.to_s, @tool_definition)
            !executable.nil?
          end
        end

        # Get the response class for a command
        #
        # @param command_name [Symbol] the command name
        # @return [Class] the response class
        def response_class_for(command_name)
          command_name = command_name.to_sym
          @response_classes ||= {}
          return @response_classes[command_name] if @response_classes[command_name]

          # Get command from platform profile model
          command_def = @platform_profile.command(command_name.to_s)
          raise ArgumentError, "Unknown command: #{command_name}" unless command_def

          # Generate the response class using ClassGenerator
          response_class = Ukiryu::Tools::ClassGenerator.generate_response_class(self, command_name, command_def)
          @response_classes[command_name] = response_class
          response_class
        end
      end

      # Initialize the tool instance
      #
      # Sets up shell and platform instance variables for CommandBuilder
      def initialize
        runtime = Ukiryu::Runtime.instance
        @platform = runtime.platform
        @shell = runtime.shell
      end

      # Get the tool name for this instance
      #
      # @return [Symbol] the tool name
      def tool_name
        self.class.tool_name
      end

      # Get the tool name from the tool definition
      #
      # @return [String] the tool name
      def name
        self.class.tool_definition.name
      end

      # Get the tool definition (for backward compatibility)
      #
      # @return [Models::ToolDefinition] the tool definition
      def tool_definition
        self.class.tool_definition
      end

      # Get the platform profile (for backward compatibility)
      #
      # @return [Models::PlatformProfile] the platform profile
      def platform_profile
        self.class.platform_profile
      end

      # Get a new options instance for a command
      #
      # @param command_name [Symbol] the command name
      # @return [Options::Base] a new options instance
      def options_for(command_name)
        self.class.options_for(command_name).new
      end

      # Get the options class for a command
      #
      # @param command_name [Symbol] the command name
      # @return [Class] the options class
      def options_class_for(command_name)
        self.class.options_for(command_name)
      end

      # Get a new action instance for a command
      #
      # @param command_name [Symbol] the command name
      # @return [Action::Base] a new action instance
      def action_for(command_name)
        self.class.action_for(command_name).new(self)
      end

      # Get the action class for a command
      #
      # @param command_name [Symbol] the command name
      # @return [Class] the action class
      def action_class_for(command_name)
        self.class.action_for(command_name)
      end

      # Get version information
      #
      # @return [String, nil] version string if tool is available
      def version
        return @version if defined?(@version)

        @version = detect_version
      end

      # Check if the tool is available
      #
      # @return [Boolean] true if the tool can be executed
      def available?
        self.class.available?
      end

      # Get the reason why the tool is not available
      #
      # Returns nil if the tool is available, or a string explaining why not.
      # This helps users understand issues like:
      # - Tool not installed
      # - Wrong version installed (e.g., impostor tool)
      #
      # @return [String, nil] reason for unavailability, or nil if available
      def unavailability_reason
        return nil if available?

        return executable_not_found_message if executable.nil?
        return version_mismatch_message if version_mismatch?

        generic_unavailable_message
      end

      # Execute a command with options object
      #
      # @param command_name [Symbol] the command to execute
      # @param options [Object] the options object
      # @param execution_timeout [Integer] timeout in seconds for command execution (required)
      # @return [Response::Base] the execution response
      def execute(command_name, options, execution_timeout:)
        command_name = command_name.to_sym
        # Get command from platform profile model
        command_def = self.class.platform_profile.command(command_name.to_s)

        raise ArgumentError, "Unknown command: #{command_name}" unless command_def

        # Convert options to hash
        params = if options.is_a?(Hash)
                   options.transform_keys(&:to_sym)
                 else
                   Ukiryu::OptionsBuilder.to_hash(options)
                 end

        # Build arguments
        args = build_args(command_def, params)

        # Find executable using ExecutableFinder
        executable = Ukiryu::ExecutableFinder.find_executable(self.class.tool_definition.name.to_s,
                                                              self.class.tool_definition)

        # Get shell
        shell_sym = Ukiryu::Runtime.instance.shell

        # Build environment variables (including env var sets)
        env = build_execution_env(command_def, @platform_profile, params)

        # Execute with explicit timeout
        result = Ukiryu::Executor.execute(
          executable,
          args,
          env: env,
          timeout: execution_timeout,
          shell: shell_sym
        )

        # Build response
        build_response(command_name, result)
      end

      private

      # Check if the executable exists
      #
      # @return [String, nil] the executable path or nil
      def find_executable
        Ukiryu::ExecutableFinder.find_executable(self.class.tool_definition.name.to_s, self.class.tool_definition)
      end

      # Message when executable is not found
      #
      # @return [String] the error message
      def executable_not_found_message
        "Tool '#{name}' not found in PATH or configured search paths. Please install the tool."
      end

      # Check if version output doesn't match expected pattern
      #
      # @return [Boolean] true if version mismatch detected
      def version_mismatch?
        vd = self.class.tool_definition.version_detection
        return false unless vd && !vd.command.nil? && !vd.command.empty?

        version_output = run_version_command
        return false unless version_output

        pattern = vd.pattern.is_a?(String) ? Regexp.new(vd.pattern) : vd.pattern
        !version_output.match(pattern)
      end

      # Run the version detection command
      #
      # @return [String, nil] the version output or nil
      def run_version_command
        vd = self.class.tool_definition.version_detection
        cmd = vd.command
        executable = find_executable
        return nil unless executable

        shell_sym = Ukiryu::Runtime.instance.shell
        # Internal operation: use hardcoded timeout
        result = Ukiryu::Executor.execute(executable, [cmd], shell: shell_sym, timeout: 30, allow_failure: true)

        result.success? ? (result.stdout + result.stderr) : nil
      end

      # Message when version doesn't match (impostor tool)
      #
      # @return [String] the error message
      def version_mismatch_message
        executable = find_executable
        "Tool '#{name}' executable found (#{executable}) but version doesn't match expected format. " \
        "You may have a similarly-named tool installed that is not the real '#{name}'."
      end

      # Generic unavailable message
      #
      # @return [String] the error message
      def generic_unavailable_message
        "Tool '#{name}' found but could not be initialized."
      end

      # Memoize executable lookup
      #
      # @return [String, nil] the executable path
      def executable
        @executable ||= find_executable
      end

      # Build command arguments from parameters
      #
      # This method extends the CommandBuilder implementation to handle
      # extra_args for manual option injection.
      #
      # @param command_def [Models::CommandDefinition] the command definition
      # @param params [Hash] the parameters
      # @return [Array<String>] the command arguments
      def build_args(command_def, params)
        # Call CommandBuilder's build_args first
        args = super

        # Handle extra_args for manual option injection
        # This allows users to pass options not defined in the YAML profile
        if params[:extra_args]
          extra = params[:extra_args]
          shell_sym = Ukiryu::Runtime.instance.shell

          if extra.is_a?(Array)
            shell_class = Ukiryu::Shell.class_for(shell_sym)
            shell_instance = shell_class.new
            extra.each { |arg| args << shell_instance.escape(arg.to_s) }
          else
            args << extra.to_s
          end
        end

        args
      end

      # Build execution environment
      #
      # @param command_def [Models::CommandDefinition] the command definition
      # @param profile [Models::PlatformProfile] the profile (for env_var_sets)
      # @param params [Hash] the parameters
      # @return [Hash] environment variables
      def build_execution_env(command_def, profile, params)
        build_env_vars(command_def, profile, params)
      end

      # Check if command needs batch processing flag for headless mode
      #
      # @param command_def [Models::CommandDefinition] the command definition
      # @return [Boolean] true if batch processing flag should be added
      def needs_batch_process_flag?(command_def)
        # Check if command uses the 'headless' env var set
        command_def.use_env_vars&.include?('headless') || false
      end

      # Build a response object
      #
      # @param command_name [Symbol] the command name
      # @param result [Executor::Result] the execution result
      # @return [Response::Base] the response object
      def build_response(command_name, result)
        # Get the response class for this command
        response_class = self.class.response_class_for(command_name)

        # Create response instance
        response_class.new(result)
      end

      # Detect the tool version
      #
      # @return [String, nil] the detected version string
      def detect_version
        vd = self.class.tool_definition.version_detection
        return nil unless vd

        # Only attempt version detection if command is configured
        # command: nil means no version detection configured
        # command: [] means run with no arguments (for tools like ffmpeg that output version on bare run)
        return nil if vd.command.nil?

        cmd = vd.command

        executable = Ukiryu::ExecutableFinder.find_executable(self.class.tool_definition.name.to_s,
                                                              self.class.tool_definition)
        return nil unless executable

        shell_sym = Ukiryu::Runtime.instance.shell

        # If command is an empty array, run executable with no arguments
        # Otherwise wrap command in array if it's a string
        args = cmd.is_a?(Array) ? cmd : [cmd]
        # Use allow_failure: true because some tools (like ffmpeg) return non-zero exit code when run bare
        result = Ukiryu::Executor.execute(executable, args, shell: shell_sym, allow_failure: true)

        # Convert pattern string to regex if needed
        pattern = if vd.pattern.is_a?(String)
                    Regexp.new(vd.pattern)
                  else
                    vd.pattern || /(\d+\.\d+)/
                  end
        # Scrub stdout/stderr to handle invalid UTF-8 byte sequences
        stdout_scrubbed = result.stdout.scrub('')
        stderr_scrubbed = result.stderr.scrub('')
        match = stdout_scrubbed.match(pattern) || stderr_scrubbed.match(pattern)
        match[1] if match
      end
    end
  end
end
